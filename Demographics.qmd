---
title: "Demographics"
format: gfm
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, paged.print = FALSE)
```

```{r}
#| message: false
library(tidycensus)
library(tidyverse)
library(ggspatial)
library(sf)
library(janitor)
library(gt)
library(areal)
library(glue)
library(spdep)
library(tigris)
library(units)
library(crsuggest)
options(tigris_use_cache = TRUE)
```

# Introduction

In this article, I would like to do a comparative analysis of various economic factors such as income, housing value, poverty and equality among the city council districts of Albuquerque. I will obtain the demographic data from `census.gov` using `tidycensus`. After cleaning, the data will be spatially joined with the council districts in order to produce both comparitive summaries of aggregated data, but also distribution analyses of the data. Finally, I will explore clustering of the data points.

# Data Preparation

## City Council Districts

I will start with the easy part, obtaining the boundaries for the city council districts. There are just two twists here: the data from the city website is useless, and; there's a big hole in the middle of Albuquerque, which is the township of Los Ranchos. The Albuquerque website provides a wealth of data, although it is not necessarily well thought-out or well-maintained. In many of the data sets, the relevant data is contained in tables embeded in html, all of which are in a single variable in the data set. In this case, the problem is worse: the website only provides the councilors' names, not district numbers, and the names are for councilors from several years ago!

Fortunately, the county website provides a reasonable dataset in the form of a zipped shapefile. And they provide a geometry for Los Ranchos. Los Ranchos is sort of the Beverly Hills of Albuquerque, in the sense that it is a separate enclave which is (almost) entirely surrounded by Albuquerque, and where the largest properties and mansions are located.

The data portal for Bernalillo county is not very friendly for programmatic downloading. My first effort to download and unzip the file containing the city council boundaries failed to produce a usable file. Adding the argument `method = "curl"` allowed me to download the file which is a zipped shapefile.

```{r}
#| eval: false
download.file("https://www.berncoclerk.gov/wp-content/uploads/2025/07/BERNCO_CLERKJuly2025.gdb_.zip", "data/bernalillo.zip", method = "curl")
unzip("data/bernalillo.zip", overwrite = T)
```

I will read the file with `sf::st_read`, which will result in an `sf` object. The only variable I'm interested in are the district number, so I'll just grab that, fix the variable name, and make the content more descriptive for easy mapping. The `geometry` is sticky, so I don't need to specify it.

```{r}
council_dists_bc <- st_read("data/BC_CityCouncil/ABQ_CityCouncils.shp") %>%
  select(district = DISTRICTNU) %>%
  mutate(district = paste("District", district))
council_dists_bc
```

The downloaded file for Los Ranchos was not complete even with the additional argument, so I had to manually download the file.

```{r}
#| eval: false
download.file("https://www.berncoclerk.gov/wp-content/uploads/2023/02/LosRanchos.zip", "data/test.zip", method = "curl")
unzip("data/LosRanchos.zip")
```

The `crsuggest` package has a useful function to determine an appropriate CRS for an `sf` object. I prefer working in meters rather than feet, so I'll choose 6528. I will change the variable name in `los_ranchos` to match that in `council_dists`, add one to the other, and transform the CRS.

```{r}
los_ranchos <- st_read("data/LosRanchos/LosRanchos.shp") %>%
  select(district = Name)

st_crs(los_ranchos) == st_crs(council_dists_bc)
suggest_crs(council_dists_bc) %>% head(2)

council_dists <- rbind(council_dists_bc, los_ranchos) %>%
  st_transform(6528)
council_dists
```

I'll plot the district boundaries with `ggplot`, adding a base map with `ggspatial::annotation_map_tile`.

```{r}
ggplot(council_dists) +
  annotation_map_tile(
    type = "osm",
    cachedir = "~/.cache/maps/",
    zoomin = -1,
    alpha = 0.7
  ) +
  geom_sf(aes(color = district), fill = NA, linewidth = 1) +
  geom_sf_text(aes(label = district)) +
  theme_void() +
  labs(title = "Albuquerque Council Districts")
```

## Census Data

I want to look at some basic demographic and economic information. I will use `tidycensus` to download data from `census.gov`, using the information from 2023's five-year American Community Survey. I want tract level data for my study area. I also want to compare to state-wide and country-wide data, so I'll grab those at a less detailed level.

Variables are easily discoverable with the useful function `tidycensus::load_variables`, which takes a year and a dataset. Once downloaded, you can use `View` to search for those of interest.

```{r}
#| eval: false
v23 <- load_variables(2023, "acs5")
View(v23)
```

The function to download the data is `get_acs()`, which takes a series of pretty self-explanatory arguments. `tidycensus` allows you to supply a named vector for variables, so that the returned table will already have useful variable names. By specifying `geometry = TRUE` I will get an `sf` object back, and specifying `output=wide` gives me a table with a seperate column for each variable.

```{r}
vars <- c(
  med_house_value = "B25077_001",
  income_hh = "B19001_001",
  population = "B01003_001",
  gini = "B19083_001",
  med_age = "B01002_001",
  in_poverty = "B17001A_002"
)
```

```{r}
#| eval: false
bern_data <- get_acs(
  geography = "tract",
  state = "NM",
  county = "Bernalillo",
  variables = vars,
  output = "wide",
  year = 2023,
  geometry = T,
  cache_table = T
)

st_write(bern_data, "data/demographics.gpkg", layer = "county", append = F)

nm_data <- get_acs(
  geography = "county",
  state = "NM",
  variables = vars,
  output = "wide",
  year = 2023,
  geometry = T,
  cache_table = T
)

st_write(nm_data, "data/demographics.gpkg", layer = "state", append = F)

us_data <- get_acs(
  geography = "state",
  variables = vars,
  output = "wide",
  year = 2023,
  geometry = T,
  cache_table = T
)

st_write(us_data, "data/demographics.gpkg", layer = "country", append = F)
```

I would like to compare education levels as well. The data for this is broken down into 25 variables, far more than I need, so I will group them. I'm also going to drop the margin of error information. Notice that, in this case, I am requesting an entire table rather than specific variables, by using the `table` argument rather than the `variable` argument.

```{r}
#| eval: false
bern_edu <- get_acs(
  geography = "tract",
  state = "NM",
  county = "Bernalillo",
  table = "B15003",
  output = "wide",
  year = 2023,
  geometry = T,
  cache_table = T
) %>%
  select(-2) %>%
  select(!ends_with("M")) %>%
  mutate(
    no_hs_deg = rowSums(across("B15003_002E":"B15003_016E")),
    hs_some_college = rowSums(across("B15003_017E":"B15003_020E")),
    bach_assoc_deg = rowSums(across("B15003_021E":"B15003_022E")),
    grad_deg = rowSums(across("B15003_023E":"B15003_025E"))
  ) %>%
  select(-c("B15003_001E":"B15003_025E"))

st_write(bern_edu, "data/demographics.gpkg", layer = "education", append = F)
```

```{r}
bernalillo_edu <-
  st_read("data/demographics.gpkg", layer = "education")
bernalillo_demographics <-
  st_read("data/demographics.gpkg", layer = "county")
```

Now let's look at the data.

```{r}
summary(bernalillo_demographics)
```

There is clean-up work to do here. There are some NAs, some areas with 0 population, an unneeded NAME column, and the ugly variable names to deal with. I also need to make sure it is in the correct crs. First I'll fix the names, drop the uninteresting columns and transform the coordinates. Then I do a simple join with the educational table based on the GEOID, dropping the geometry from one, and then dropping the error values.

```{r}
fix_names <- function(df) {
  df %>%
    rename_with(~ sub("E$", "", .)) %>%
    rename_with(~ sub("M$", "_moe", .))
}

bernalillo_demographics <-
  bernalillo_demographics %>%
  select(-2) %>% 
  fix_names() %>%
  st_transform(6528)


bernalillo_demographics <- bernalillo_demographics %>%
  left_join(st_drop_geometry(bernalillo_edu), by = "GEOID") %>%
  select(!ends_with("moe"))

summary(bernalillo_demographics)
```

Let's look at the 0 population areas.

```{r}
bernalillo_demographics %>% filter(population == 0)
```

These contain no useful information, so I'll drop them. With regarding to the remaining missing values, there are so few that I'll just replace them with averages.

```{r}
bernalillo_demographics <- bernalillo_demographics %>%
  filter(population != 0) %>% 
  mutate(
    med_house_value = ifelse(is.na(med_house_value),
      median(med_house_value, na.rm = T),
      med_house_value
    ),
    gini = ifelse(is.na(gini),
      mean(gini, na.rm = T),
      gini
    )
  )

summary(bernalillo_demographics)
```

Most of the data seems normal, now. I am curious about the tract(s) with no household income and very small populations. Are they the same?

```{r}
bernalillo_demographics %>% 
  filter(income_hh < 100 | population < 150)
```

The duplicate house value is suspicious, the income for the first is clearly wrong. I'm going to remove the second record, since there are so few people, and the household income, if correct, is an extreme outlier. I'll just use an average value for the income in the first record.

```{r}
bernalillo_demographics <- 
  bernalillo_demographics %>% 
  filter(population > 20) %>% 
  mutate(
    income_hh = ifelse(income_hh == 0, median(income_hh), income_hh)
  )

summary(bernalillo_demographics)
```

Before combining this data with the council district shapes, I want to calculate the area for each tract, which I'll need later. I'll use this to also calculate a population density for each area. Using the `units` package, I can do this easily in both square kilometers and square miles without explicitly calculating them, even though the CRS is in meters.

```{r}
bernalillo_demographics$area <- 
  st_area(bernalillo_demographics) %>% 
  set_units(km^2)

bernalillo_demographics$area_smi <- 
  st_area(bernalillo_demographics) %>% 
  set_units(mi^2)

bernalillo_demographics$pop_dens <-
  bernalillo_demographics$population / bernalillo_demographics$area

bernalillo_demographics$pop_dens_smi <-
  bernalillo_demographics$population / bernalillo_demographics$area_smi
```

I would like to to calculate per-person values for the extensive variables.

```{r}
demo_pcts <- 
  modify(bernalillo_demographics[7:11], 
       \(x) x / bernalillo_demographics$population) %>% 
  rename_with(~ sub("$", "_pp", .), .cols = everything()) %>% 
  st_drop_geometry()

bernalillo_demographics <- 
  bernalillo_demographics %>% 
  cbind(demo_pcts)

summary(bernalillo_demographics)
```

## Combining the data

Now I need to combine the data. By using `st_intersection()` I can split the demographic by council district. Since I'm not interested in areas outside the districts, I'll then crop the data.

```{r}
#| eval: false
cd_demographics <- 
  st_intersection(bernalillo_demographics, council_dists) %>% 
  st_crop(st_bbox(council_dists))
cd_demographics %>% 
  arrange(GEOID) %>% 
  select(GEOID, population, no_hs_deg)
```

As you can see, we now have separate slices for tracts which span more than one district, but the data has been copied into each new row. For intensive variables like medians this is okay, but for extensive variables like population, they must be spread across the new areas. I'll do this based on areal proportioning. First I'll calculate the areas of each new subdivision, and the percentage they represent of the former regions. This allows me to re-calculate the extensive variables, assigning the proper proportion to each.

```{r}
cd_demographics$area_split <- 
  st_area(cd_demographics) %>% 
  set_units(km^2)

cd_demographics <- cd_demographics %>% 
  group_by(GEOID) %>% 
  mutate(
    area_pct = area_split / area,
    population = population * area_pct,
    in_poverty = in_poverty * area_pct,
    no_hs_deg = no_hs_deg * area_pct,
    hs_some_college = hs_some_college * area_pct,
    bach_assoc_deg = bach_assoc_deg * area_pct,
    grad_deg = grad_deg * area_pct
  ) %>% 
  arrange(GEOID)

st_write(cd_demographics, "data/cd-demographics.gpkg", append = F)

options(scipen = 100)

cd_demographics %>% 
  arrange(GEOID) %>% 
  select(GEOID, population, no_hs_deg)
```

```{r}
cd_demographics <- st_read("data/cd-demographics.gpkg")
```

Let's take a look, finally, at what we have. First, a few maps:


```{r}
ggplot(cd_demographics) +
  annotation_map_tile(
    type = "osm",
    cachedir = "~/.cache/maps/",
    zoomin = -1,
    alpha = 0.6
  ) +
  geom_sf(aes(fill = in_poverty), alpha = 0.4) +
  geom_sf(data = council_dists, aes(color = district), 
          fill = NA, linewidth = 0.5) +
  geom_sf_text(data = council_dists, aes(label = district)) +
  scale_fill_viridis_c() +
  scale_color_viridis_d(guide = "none") +
  theme_void() +
  labs(
    title = "2023 People in Povery in Albuquerque, NM",
    subtitle = "By census tract",
    caption = "Source: census.gov ACS",
    fill = "People\n in Poverty"
  )
```

```{r}
ggplot(cd_demographics) +
  annotation_map_tile(
    type = "osm",
    cachedir = "~/.cache/maps/",
    zoomin = -1,
    alpha = 0.5
  ) +
  geom_sf(aes(fill = as.numeric(pop_dens)), alpha = 0.4) +
  geom_sf(data = council_dists, aes(color = district), fill = NA, linewidth = 1) +
  geom_sf_text(data = council_dists, aes(label = district)) +
  scale_fill_viridis_c() +
  scale_color_viridis_d(guide = "none") +
  theme_void() +
  labs(
    title = "2023 Population Density in Albuquerque, NM",
    subtitle = "By census tract",
    caption = "Source: census.gov ACS",
    fill = "Population\n Density"
  )
```

```{r}
ggplot(cd_demographics, aes(x = income_hh, y = district)) +
  geom_boxplot() +
  geom_jitter(height = 0.1, color = "blue", size = 1, alpha = 0.6) + 
  coord_flip() +
  labs(
    title = "2023 Household Income in Albuquerque, NM",
    subtitle = "By district",
    caption = "Source: census.gov ACS"
  )
```

```{r}
ggplot(cd_demographics) +
  annotation_map_tile(
    type = "osm",
    cachedir = "~/.cache/maps/",
    zoomin = -1,
    alpha = 0.5
  ) +
  geom_sf(aes(fill = income_hh), alpha = 0.4) +
  geom_sf(data = council_dists, aes(color = district), fill = NA, linewidth = 1) +
  geom_sf_text(data = council_dists, aes(label = district)) +
  scale_fill_viridis_c() +
  scale_color_viridis_d(guide = "none") +
  theme_void() +
  labs(
    title = "2023 Household Income in Albuquerque, NM",
    subtitle = "By census tract",
    caption = "Source: census.gov ACS",
    fill = "Median\nHousehold\nIncome"
  )
```


```{r}
ggplot() +
  annotation_map_tile(
    type = "osm",
    cachedir = "~/.cache/maps/",
    zoomin = -1,
    alpha = 0.5
  ) +
  geom_sf(data = cd_demographics, aes(fill = pop_dens), alpha = 0.4) +
  geom_sf(data = council_dists, aes(color = district), fill = NA, linewidth = 1) +
  geom_sf_text(data = council_dists, aes(label = district)) +
  scale_fill_viridis_c() +
  scale_color_viridis_d(guide = "none") +
  theme_void()
```

```{r}
bern_blocks <- blocks(state = "NM", county = "Bernalillo", year = 2020) %>%
  st_transform(st_crs(bernalillo_demographics))
names(bern_blocks)
```

```{r}
names(bernalillo_demographics)
bern_tract_ext <- bernalillo_demographics %>%
  select(c(population, no_hs_deg, hs_equivalent, some_college, bach_assoc_deg, grad_deg))
bern_tract_int <- bernalillo_demographics %>%
  select(med_house_value, income_hh, income_pc, gini, med_age)
```

```{r}
bern_demo_int <- interpolate_pw(
  bern_tract_ext, council_dists,
  to_id = "district", extensive = TRUE,
  weights = bern_blocks, weight_column = "POP20"
)

bern_demo_ext <- interpolate_pw(
  bern_tract_int, council_dists,
  to_id = "district", extensive = FALSE,
  weights = bern_blocks, weight_column = "POP20"
)

council_totals <- cbind(
  bern_demo_int %>% arrange(district),
  bern_demo_ext %>% arrange(district) %>% st_drop_geometry()
)
```

```{r}
names(council_totals)
```

```{r}
council_totals %>%
  st_drop_geometry() %>%
  select(district, population, med_house_value, income_hh, income_pc, med_age, gini) %>%
  gt(rowname_col = "district") %>%
  cols_label(
    population = "Population",
    med_house_value = "Med House Value",
    income_hh = "HH Income",
    income_pc = "PC Income",
    med_age = "Age",
    gini = "GINI"
  ) %>%
  tab_header(
    title = md("**Basic Demographics for Albuquerque**")
  ) %>%
  tab_source_note(
    source_note = md("*Source: census.gov, acs5, 2023*")
  ) %>%
  opt_stylize(style = 2) %>%
  fmt_currency(
    columns = c(med_house_value, income_hh, income_pc),
    decimals = 0
  ) %>%
  fmt_number(columns = "med_age", decimals = 1) %>%
  fmt_number(columns = "gini", decimals = 3) %>%
  fmt_number(columns = "population", decimals = 0)
```

Replace NAs with median value for district

```{r}
bernalillo_demographics$area <- st_area(bernalillo_demographics)

names(bern_by_dist)

bern_by_dist <- st_intersection(bernalillo_demographics, council_dists) %>%
  group_by(GEOID) %>%
  mutate(weight = area / sum(area)) %>%
  mutate(
    population_w = population * weight,
    no_hs_deg_w = no_hs_deg * weight,
    hs_equivalent_w = hs_equivalent * weight,
  ) %>%
  arrange(GEOID)
bern_by_dist

plot(bern_by_dist)
```

## Population

```{r}
library(data.table)
demographics_dt <- demographics %>%
  st_drop_geometry() %>%
  as.data.table()
```

```{r}
income <- demographics_dt[income_hh > 10]
```

```{r}
ggplot(income, aes(income_hh)) +
  geom_histogram(bins = 15) +
  facet_wrap(~district) +
  labs(
    title = "2023 Household Income in Albuquerque, NM",
    subtitle = "By district",
    caption = "Source: census.gov ACS"
  )
```

```{r}
ggplot(demographics, aes(x = district, y = income_hh)) +
  geom_boxplot(aes(fill = district)) +
  theme_bw() +
  labs(
    y = "Household Income",
    title = "2023 Household Income in Albuquerque, NM",
    subtitle = "By district",
    caption = "Source: census.gov ACS"
  ) +
  theme(
    legend.position = "bottom",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    legend.title = element_blank()
  )
```



```{r}
bern_blocks <- blocks(state = "NM", county = "Bernalillo", year = 2020) %>%
  st_transform(st_crs(bernalillo_demographics))
names(bern_blocks)
```

```{r}
names(bernalillo_demographics)
bern_tract_ext <- bernalillo_demographics %>%
  select(GEOID, population, no_hs_deg, hs_some_college, 
           bach_assoc_deg, grad_deg)
bern_tract_int <- bernalillo_demographics %>%
  select(GEOID, med_house_value, income_hh, 
         gini, med_age)
```

```{r}
bern_demo_int <- interpolate_pw(
  bern_tract_ext, council_dists,
  to_id = "district", extensive = TRUE,
  weights = bern_blocks, weight_column = "POP20"
)

bern_demo_ext <- interpolate_pw(
  bern_tract_int, council_dists,
  to_id = "district", extensive = FALSE,
  weights = bern_blocks, weight_column = "POP20"
)

names(bern_tract_ext)

bern_tract_ext

interpolate_pw(
  council_dists, bern_tract_int,
  to_id = "GEOID", extensive = FALSE,
  weights = bern_blocks, weight_column = "POP20"
)

council_totals <- cbind(
  bern_demo_int %>% arrange(district),
  bern_demo_ext %>% arrange(district) %>% st_drop_geometry()
)
summary(council_totals)
```

```{r}
names(council_totals)
```

